<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
    <!--
<link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
<script type="text/javascript" src="../css/issStyle.js"></script>
-->
<style type="text/css">
body
{
    margin-left:  30px;
    margin-right: 30px;
};

P
{
    font-family: Tahoma;
    font-size: 10pt;
};

a, a:visited, a:active, a:link, a:hover {
    text-decoration: underline;
    color: #545454;
    background-color: transparent;
	font-size: 93%;
}

a:hover {
    background-color: #cccccc;
}


hr {
    clear: both;
    height: 1px;
    color: #242424;
    background-color: transparent;
}

h1, h2, h3 {
    color: #242424;
    clear: left;
    font: 100% Tahoma, Helvetica, Arial, sans-serif;
    margin-bottom: 0.5em;
    padding-top: 0.5em;
	border-radius: 10px;
	padding: 5px;
}

top {
	width: 100%;
}


#i {
    color: #ff1010;
}
tt{
	font-family: "Arial";
    font-size: 90%;
	color: #006600;
}
em{
	font-family: "Arial";
    font-size: 80%;
	font-weight: bold;
	border-style:solid;
	border-color: #abe876;
    color: #1632cc;
}
bc{
	font-family: "Arial";
	font-size: 90%;
	font-weight: bold;
    color: #990000;
	background-color: #fcf8c7;
}
ks{
	font-family: "Arial";
	font-weight: bold;
    color: #0000CD	;
	font-size: 90%;
}
kc{
	font-family: "Arial";
	font-weight: bold;
    color: #008000	;
	font-size: 90%;
}
pre{
	font-family: "Consolas";
	font-size: 85%;
	background-color: #f5f5f5;
	border: 1.5px solid silver;
	padding: 5px;
}
m{
	font-family: "Helvetica";
	line-height: 100%;
 	font-size: 75%;
}
div.body{
	 
    font-size: 18px;
}
k{
    color: #990000;
	font-weight: bold;
	font-size: 90%;
}
h1 {
    font-size: 150%;
    background-color: #b2c0ff;
	padding: 10px;
}

h2 {
    background-color: #9ed8ff;
    font-size: 130%;
}

h3 {
	background-color: #e6ccff;
    font-size: 100%;
}
h4 {
    background-color: #ccffcc;
    font-size: 100%;
	width: 95%;
	border-radius: 5px;
	padding: 2px;
}
h5 {
    background-color: #d5ffb0;
    font-size: 100%;

}
div.req{
	background-color: #d9ffb3;
    font-size: 18px;
	width: 700px;
    border: 3px solid green;
    padding: 15px;
    margin: 10px;
}
div.remark{
	background-color: #E3F2FD;
    border: 1.5px solid #d5f2ed;
    padding: 15px;
    margin: 10px;
	border-radius: 25px;
}
table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}

ol, ul, li {
  margin: 0;
  margin-left: 10px;
  padding: 0;
  padding-bottom: 5px;
}

table, th, td {
	border: 1px solid black;
}

img {
	border: 1.5px solid #d5f2ed

}

a, a:visited, a:active, a:link, a:hover {
    text-decoration: underline;
    color: #545454;
    background-color: transparent;
}

div.wrapdesc{
	width: 90%;
	margin: auto;
}

div.imagedesc{
	width: 85%;
	margin: auto;
}
</style>
    
<head>
   
<title>Domande</title></head>
    
<body>


<div id="top">
<h1>Lab ISS2021 | Domande  <font size="5"></font> </h1>

Riportiamo qui un elenco di possibili domande di riferimento per i colloqui orali:
<ol>
<li>Abbiamo appena visto il funzionamento della applicazione. Possiamo vedere il <em>progetto</em>?
Quale rappresentazione (linguaggio naturale, diagrammi UML, modelli, figure, parti di codice, ...) propone per l'espozione del progetto?</li>
<li>Che forma assume il deliverable di progetto e come è stato prodotto? Vi sono connessioni cone la fase di <em>analisi del problema</em>?
E con la fase di analisi dei requisiti?</li>
<li>Come ci può convincere che l'applicazione 'copre' tutti i <em>requisiti</em> dati senza doverla eseguire caso per caso?</li>
<li>Può mostrare la struttura della <em>architettura finale</em> del sistema? In quale forma ritiene sia più opportuno presentare
l'architettura (o in generale <i>una architettura software</i> per poterne discutere in modo <i>pragmaticamente utile</i>
(cioè non solo in modo vago e discorsivo)?</li>
<li>L'architettura finale è' stata preceduta dalla definizione di una <em>archittura logica</em>  scaturita come deliverable della fase
di analisi del problema?  </li>
<li>Quali sono i punti salienti che sono stati posti in luce nella fase di analisi del problema?
E' stato evidenziato qualche <em>punto particolamente critico</em>?</li>

<li>E' possibile, seocndo lei, definire un <em>modello</em> eseguibile del sistema già al termine della fase di analisi <em>dei requisiti</em>?
Se sì, quali vantaggi se ne potrebbero trarre? Se no, perchè non lo ritiene possibile?
</li>
<li>Immagino che come linguaggio di codifica si sia usato principlamente Java e/o Kotlin, 
insieme a qualche parte scritta in C, C++, Python, JavaScript, etc).
Nella fase di analisi del problema, è stato evidenziato qualche macroscopico <em>gap</em> rispetto queste tecnologie?
Se sì' come si è pensato di colmare questo 'abstracton gap'?</li>

<li>Fino a che punto è utile introdurre <em>diagrammmi UML</em> e per quali scopi? Quali sono le motivazioni che possono indurre
una software-house a definire linguaggi (o metamodelli) Doamin-specific?</li>

<li>In ambiente industriale non è possibile pensare che sia possibile utilizzare il metamodello QActor.
Ma di certo è diffuso l'uso delle librerie. Secondo lei sarebbe possibile affrontare lo sviluppo di applicazioni
distribuite usando solo la libreria <em>it.unibo.qakactor-3.jar</em> e quelle ad essa necessarie?  </li>
<li>Ha trovato un qualche vantaggio nell'uso dei QActor attraverso un <em>linguaggio custom</em> (di ispirazione DSL)
dotato di un suo proprio IDE? Ha una idea di come sia stato prodotto l'<em>IDE per i qak</em> in ambiente Eclipse?</li>

<li>Le mostro l'architettura logica proposta dal gruppo xyz. Trova questa <em>architettura logica concordante</em> con la sua o è possibile evidenziare
macroscopiche differenze?. Se nota  differenze, le possiamo tollerare o no?</li>

<li>In quale fase (analisi, progetto,...) è stata decisa la <em>natura software dei componenti</em> del sistema; quali sono
le motivazioni per queste scelte, e dove sono riportate/discusse?</li>
<li>In quale fase (analisi, progetto,...) è stata decisa la <em>interazione tra i componenti</em> del sistema; quali sono
le motivazioni per queste scelte, e dove sono riportate/discusse?</li>
<li>In quale fase dello sviluppo è stata definita una <em>pianificazione dei lavori</em> e una loro ripartizione tra i componenti del team?</li>
<li>In quanti <em>Sprint</em> Scrum-like si è svolto lo sviluppo del software?</li>
<li>Durante la fase di sviluppo, è stato necessario <em>rivedere qualche parte della analisi del problema</em>? In altre parole,
sono state trovate situazioni che l'analista non aveva previsto o aveva affrontato in modo incompleto? Se sì, ha
qualche esempio? E come si è procduto in questo caso?</li>
<li>E' possibilie sapere, per <em>ciascun componente</em> del team, di quali aspetti del sistema si è specificatmante occupato?
Quando sono state definite e da chi queste ripartizioni dello sviluppo?</li>
<li>In quale fase dello sviluppo sono stati impostati programmi per il testing? Quali <em>tipi di test</em> (unit, integration, functional,...) 
sono stati pensati e quali effettivamente realizzati?
</li>
<li>L'architettura finale del sistema mostra qualche <em>pattern architetturale</em> riconoscibile (ad es. client-server, layer, clean ...)  
e in quale fase dello sviluppo (analisi/progetto) è stato deciso di introdurlo? E perchè? Queste motivazioni sono riportate/discusse 
in qualche documento?</li> 
<li>E' possibile utilizzare l'applicazione avvalendosi di un <em>Browser</em>? Se no, per quale motivo si e' esclusa questa possibilità?</li>
<li>Come viene rappresentato lo stato del sistema? 
E' uno stato 'concentrato', cioè gestito da un solo componente o distribuito tra più componenti?
Chi e quando ha preso una decisione in merito a questo punto? </li>
<li>Come è stato affrontato il requisito <em>xyz</em>? </li>

<li>Il sistema finale utilizza un DDR robot virtuale. Cosa bisognerebbe fare per utilizzare un robot fisico e quanto tempo
sarebbe necessario per il refactoring del sistema?</li>
<li>Il sistema finale e' stato sviluppato tenendo conto dei principi <em>SOLID</em>? E' possibile vederne qualche esempio?</li>
<li>E' stato utilizzato il linguaggio <em>Prolog</em>? Se sì, per quale motivo?</li>
<li>Sono state utilizzate <em>annotazioni</em> Java? Se sì, in quali parti o in quali funzionalità e per quale motivo?</li>
<li>Per un eventuale supporto Web, quale framework è stato utilizzato? <em>Spring</em> o <em>Node/Express</em>? Quali sono le motivazioni della scelta?</li>
<li>Il sistema finale coinvolge anche un <em>RasperryPi</em>? Se si, quale parte del sistema è stato deployed sul Rasp e in quale modo?
</li>
<li>E' stato tentato un deplyoment della applicazione (o di parti di essa) utilizzando <em>docker</em>? E <em>docker-compose</em>?
Se sì quali sono i criteri/motivazioni per la ripsartizione di parti applicative su docker?</li>
</ol>


<!--
<a href="http://htmlpreview.github.com/?https://github.com/anatali/issLab2021/blob/main/it.unibo.issLabStart/userDocs/LectureBologna2021.html" target="isslm">ISS-lectures site</a></font> 
-->
</div>  

 <!--
 Manfreda Andrini Cristaudo
il documento template2021.html costituisce un punto di riferimento ma è
'process agnostic', cioè non indica il processo di sviluppo che adottiamo
per costruirlo.
Possiamo certo ANALIZZARE il sistema nella sua interezza, ma non
subito per 'progettarlo'.

L'analisi dei requisiti e del sistema NON IMPLICA ancora alcuna progettazione,
ma mira definire COSA il committente intende e QUALI problematiche
occorre affrontare, una volta capito cosa bisogna fare.

In questo senso, il lavoro svolto da voi fino ad ora 
sembra più rivolto alla costruzione di una soluzione (con riferimento a WENV
e non al sistema richiesto) che non alla analisi.

Va benissimo organizzare tutte le funzionalità per importanza, ma occorre anche
analizzare come distribuirle tra i vari componenti che l'analisi individua,
una volta chiariti i requisiti.
Questa fase deve mettere in luce le possibili alternative, per individuare quelle
più opportune, insieme alle tecnologie che l'analista ritiene più opportuno
suggerire (o imporre) al progettista.

Un approccio INCREMENTALE (in stile SCRUM, ma non solo) è utile per 
aggredire la complessità del problema e per
mettere in luce in primis LE COSE
PIU' IMPORTANTI e PIU' CRITICHE senza perdersi in dettagli che possono distogliere
l'attenzione per formarsi un quadro generale di riferimento.

Questo quadro può essere sintetizzato nella definizione di una architettura logica
che definisce la NATURA (oggetti, processi, servizi, attori, database, etc.) 
dei MACRO-COMPONENTI del sistema e della loro
interazione, NON COME SOLUZIONE DI PROGETTO, ma come 
VINCOLI IMPLICATI dal problema.

QUELLO CHE VIENE DETTO DA UN ANALISTA DOVREBBE ESSERE
CONDIVISO DA OGNI ALTRO ANALISTA, PRIMA DELLA PROGETTAZIONE.

L'uso dei modelli è utile (per non dire indispensabile) PER CONCENTRARE
l'attenzione SUGLI ASPETTI RITENUTI SALIENTI (tenendo conto anche
dei tempi, delle tecnologie disponibili  e dei costi):

Inoltre, l'architettura logica può essere il riferimento per la impostazione di
PIANI di testing (unit, integration, functional, acceptance) espressi in MODO
NON discorsivo (formale), comprensibile a una macchina. 
Per questo noi abbiamo perseguito l'idea di modelli eseguibili, sviluppando
una meta-modello in modo custom, visto che si trova ancora
nulla di questo tipo in rete.

 I vari SPRINT dovrebbero effettuare uno ZOOMING entro MACRO-COMPOMENTI
innescando un processo ITERATIVO di analisi, progetto , sviluppo e testing di
quel componente o del SOTTOSISTEMA  che lo sprint vuole costruire.
Per questo può essere opportuno impostare ogni sprint come un 'sottoprogetto'
con sua propria spiegazione e teasting. Lo sprint n+ dovrebbe partire dai
risultati dello sprint n e preparare un subsystem (funzionante) 
che sarà l'input dello sprint n+2.


Marchesini
L'analisi dei requisiti potrebbe essere formalizzata introducendo un modello 'conprensibile alla macchina'. Inoltre non sono informazioni relative al software fornito/voluto dal committente. Le informazioni date in linguaggio naturale sono pressochè inservibili
Ok sulla analisi della mappa e sulla possibilità/necessità di calibrazione, ma NON per il virtual environment (che non riguarda i requisiti, ma solo una fase dello sviluppo)
Si parla di Plan senza spiegare cosa si intende. Ovviamente, anche il termine SubPlan risulta oscuro
L'architettura logica dovrebbe essere largamente condivisa tra tutti gli analisti
Si parla di actor (termine usato anche nei requisiti) ma non si spiega nulla in proposito
Nella figura si usano simboli grafici non spiegati. A questo punto non è solo la 'macchina' a non capire, ma nemmeno un lettore umano
L'idea di uno Status Actor è sicuramente una idea progettuale: non scaturisce certo nè dai requisiti nè dal problema in sè
Frasi del tipo: "Status sends a message to Planner the message READY [TOKENID, current position, destination]. 
Status contains a ParkInQueue for managing cars in the parking phase, a SlotList for parked cars, 
and a ParkOutQueue for cars in the collection phase".sono una 'intenzione di progetto'. 

E' importante capire che non servono a molto se non sono 'formalizzate'. 
Per questo noi abbiamo introdotto modelli eseguibili, anche per non dover ricorrere a diagrammi di sequenza 
come quelli forniti ma che possono introdurre incomprensioni tra esseri umani, 
in quanto di origine UML e quindi object-oriented.

Gli Usecase e TestPlan indicati possono essere utili come commenti da inserire in una o più TestUnits.

L'analisi del problema serve per capire quali sono le maggiori problematiche da affrontare, le tecnologie da usare e le risorse (umane e temporali) necessarie.  Inoltre gettano le basi per impostare il primo sprint di sviluppo e quindi per costruire un prio 'prototipo' funzionante del sistema da estendere poi in modo incrementale con gli sprint succesivi dopo una opportuna sprint-review con il committente

Ritengo dunque necessario:
Costruire subito un repository GIT del progetto
Definire un primo modello del sistema come risultato della analisi del problema (e non del progetto della soluzione)
Includere nel documento di analisi gli appropriati riferimenti al modello
Definire qualche testplan significativo (cioè legato ai casi di uso) basato sul modello
 -->

<div >
<hr/>
By Antonio Natali 
<img src="./img/teacher.gif" alt="teacher" width="5%" height="5%"> antonio.natali@unibo.it  
</div> 
</body>
</html>