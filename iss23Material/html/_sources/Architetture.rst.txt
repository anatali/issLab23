.. role:: red 
.. role:: blue 
.. role:: remark
.. role:: worktodo


.. _OpenGroupArch : https://it.wikipedia.org/wiki/The_Open_Group_Architecture_Framework

======================================
Architetture
======================================


La moderna costruzione del software riconosce all'architettura del sistema un ruolo strategico, 
nonostante il termine *architettura* sia tra i vocaboli più sovraccarichi di significato.

Normalmente, si parla di :blue:`architettura di un sistema` quando ci si vuole riferire all'insieme delle 
macro-parti in cui il sistema si articola, includendo le loro responsabilità, relazioni e interconnessioni. 

Per molti, il termine *architettura* potrebbe però evocare l'immagine di uno schema in cui compare una rete 
di blocchi e linee di connessione; questa visione andrebbe meglio indicata col termine **mappa**. 

Per altri, l'*architettura* evoca l'idea di uno schema concettuale di soluzione riferito a un certo dominio applicativo, 
come ad esempio nella frase *architetture web*; in questo caso sarebbe più appropriato utilizzare il termine **framework**.

L' Open Group Architectural Framework (`OpenGroupArch`_) definisce architettura:

- "a set of elements depicted in an architectural model and a specification of how these elements are connected 
  to meet the overall requirements of an information system".

.. BCK03

Altrove  si dice che:

- "the software architecture of a program or computing system is the structure 
  or structures of the system, which comprises software components, the externally-visible properties 
  of these components and the relationships among them".

La IEEE Computer society definisce (nel 2000) l'architettura:

- "the fundamental organization of a 
  system embodied in its components their relationships to each other and to the environment, 
  and the principles guiding its design and evaluation".

Tra le altre accezioni possibili, una delle più curiose, su cui vale la pena di riflettere, è quella per cui:
 
 - l'architettura è ciò che rimane di un sistema quando non si può più togliere nulla, 
   continuando a comprenderne la struttura e il funzionamento.

Le prime esperienze collettive nello studio delle architetture software possono essere fatte 
risalire al workshop OOPSLA del 1981 guidato da Bruce Anderson che mirava allo sviluppo 
di un "architecture handbook". 




.. list-table:: 
   :widths: 70,30
   :width: 100%

   * - Nel testo ``FSA - ISBN-10 : 1492043451`` vengono presentati diversi tipi di Architetture Sosftware." 
     - .. image:: ./_static/img/Architectures/softwareArch.webp
         :width: 80%

   * - Il testo  ``CA  - ISBN-10 : 0134494164``  approfondisce il ruolo delle architetture nel processo di produzione del software."
     - .. image:: ./_static/img/Architectures/cleanArchBook.jpg
        :width: 80%
  
Da questi testi leggiamo:

- Architecture is about the important stuff ... whatever that is (Ralph Johson) (FSA pg. 1)

- Everything in software architecture is a trade-off. (**First law** of Software Architecture) (FSA pg. 18)

- :blue:`Why` is more important than :blue:`how`. (**Second law** of Software Architecture) (FSA pg. 18)

- The architecture for a software system arises from the combinations of requriments and additional concerns 
  (Auditability, Security, Legality, Scalability ...
  :blue:`-ilities` si veda `List of system quality attributes <https://en.wikipedia.org/wiki/List_of_system_quality_attributes>`_)
  each protected by fitness functions 

- All architecture become iterative becuase of :blue:`unknown of unknowns` (FSA pg. 14). 
  What we need today is an :blue:`Evolutionary Architecture`. (FSA pg. 15).

- An *Evolutionary Architecture* supports guided, incremental changes across multiple dimensions, including -ilities
  


Altrove (ad esempio in *Building Evolutionary Architectures* - ``ISBN : 9781492043454`` ) leggiamo:

- The software development ecosystem (tools, frameworks, prectices, ..) forms a dynamic equilibrium - much like a biological system.

- The *Continuos Delivery* and *DevOps* movements added a new factor in the dynamic equilibrium.  

- :remark:`To build evolvable software systems, architets must think beyond just the technical architecture.`

--------------------------------------
Architetture preliminari
-------------------------------------- 


.. csv-table::  
    :align: left
    :widths: 50, 50
    :width: 100%

    :blue:`bigballofmud`,:blue:`clientServer`
    .. image:: ./_static/img/Architectures/bigballofmud.png,.. image:: ./_static/img/Architectures/clientServer3Tier.png
    "obbrobrio (122/52)","3 tier (124)"

--------------------------------------
Architetture monolitiche
-------------------------------------- 

.. csv-table::  
    :align: left
    :widths: 33, 33, 33
    :width: 100%

    :blue:`Layers`,:blue:`Pipeline`, :blue:`microkernel`
    .. image:: ./_static/img/Architectures/layered.png , .. image:: ./_static/img/Architectures/pipline.png, .. image:: ./_static/img/Architectures/microkernel.png
    "(145)","(151/58)"


--------------------------------------
Architetture distribuite
-------------------------------------- 

.. csv-table::  
    :align: left
    :widths: 33, 33, 33
    :width: 100%

    :blue:`service-based`, :blue:`Event-driven`, :blue:`Space-based`
    .. image:: ./_static/img/Architectures/service-based.jpg, .. image:: ./_static/img/Architectures/event-driven-broker.png, .. image:: ./_static/img/Architectures/Space_based_architecture.gif
    "(163)","(179/70)","211/63"



.. csv-table::  
    :align: left
    :widths: 50, 50
    :width: 100%

    :blue:`Service-oriented`, :blue:`Microservices` 
    .. image:: ./_static/img/Architectures/soa-esb.png, .. image:: ./_static/img/Architectures//microservices.png
    "(235/65)","(245/68)" 



A queste aggiungiamo le seguenti:
    
--------------------------------------
Architetture per applicazioni
-------------------------------------- 

.. csv-table::  
    :align: left
    :widths: 33, 33, 33
    :width: 100%

    :blue:`Hexagonal`, :blue:`Subsumption`,:blue:`IOT`
    .. image:: ./_static/img/Architectures/hexArchitectureInKotlin.svg, .. image:: ./_static/img/Architectures/Subsumption_ArchitectureRobotic.gif, .. image:: ./_static/img/Architectures/iot0.png
    " "," ",""



-----------------------------------------
Architettura Esagonale (Port-Adapter)
-----------------------------------------

Il concetto di `Hexagonal Architecture <https://en.wikipedia.org/wiki/Hexagonal_architecture_(software)>`_ 
è stato introdotto nel 2005 da Alistair Cockburn come un contributo
ad evitare ben note 'trappole strutturali' nella progettazione ad oggetti, come ad esempio
dipendenze non desiderate tra layers o indebite inserzioni di codice applicativo nel codice
delle interfacce-utente.

Si tratta di un approccio alternativo alle tradizionali architetture 'a livelli' e, a detta di molti,
segna anche l'origine delle *architetture a microservizi*. In sintesi, questo approccio:

- Rende un'applicazione inconsapevole (e quindi indipendente) della natura dei dispositivi di ingresso.
  Un evento giunge dal mondo esterno tramite una porta e un opportuno adapter converte l'evento in una
  chiamata di procedura o in un messaggio verso l'applicazione.

- Rende un'applicazione inconsapevole (e quindi indipendente) della natura dei dispositivi di uscita: 
  quando essa deve emettere informazione
  verso il mondo esterno, utilizza una porta associata ad un adapter che crea gli opportuni segnali
  necessari per la specifica tencologia ricevente (umana o automatizzata).

.. image:: ./_static/img/Architectures/portAdapterArch.png
   :width: 70% 

- Un'applicazione ha una interazione con gli adapter legata alla sua propria semantica interna e 
  non deve conoscere la natura di ciò che compare al di là degli adapter. 

- :remark:`Permette di sviluppare e testare un'applicazione in modo indipendente da eventuali dispositivi run-time
  e/o database e di essere egualmente attivabile da utenti umani, programmi, test automatizzati o scripts.`

.. image:: ./_static/img/Architectures/hexlinear.PNG
   :width: 80%  

 

--------------------------------------
La Clean Architecture
-------------------------------------- 

Proposta nel 2012 da `Robert C. Martin <https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html>`_
specializza l'archiotettura esagonale fornendo ulteriori dettagli sui componenti, che sono presentati
in anelli concentrici.

.. csv-table::  
    :align: center
    :widths: 50,50
    :width: 100% 

    .. image:: ./_static/img/Architectures/cleanArch.jpg,.. image:: ./_static/img/Architectures/cleanArchCone.jpg 


Gli adapter e le interfacce sono relegate negli anelli più esterni, mentre le parti centrali sono riservate
alle entità e ai casi d'uso.

:remark:`Viene imposto il vincolo che sono sempre gli anelli esterni a dover dipendere da quelli interni e mai viceversa.`

.. list-table:: 
   :widths: 50,50
   :width: 100%

   * - :blue:`Entità`
        - Rappresenta un oggetto del :blue:`dominio applicativo`.
        - Può essere un oggetto aziendale con metodi oppure un insieme di strutture dati e funzioni. 
        - Realizza logica applicativa di tipo generale.
        - 
     - :blue:`Use Cases`
        - Rappresentano le :blue:`azioni applicative specifiche`.
        - Non sono influenzate da infrastrutture (ad es. database).
        - Non sanno chi li attiva e a chi/come inviare i risultati,
          ma usano interfacce.
        - Possono generare eccezioni a livello business.
   * - :blue:`Controllers`
        - Sono anche detti :blue:`Interface Adapters`.
        - Recuperano e memorizzano dati implementando le interfacce richieste dagli use-cases.
        - Convertono i dati (fornendo presentatori, visualizzazioni)
     - :blue:`External Interfaces`
        - Incorporano drivers e :blue:`frameworks`  che fungono da collante.
        - Usano le infrastrutture che si ritengono più appropriate.
        - 


--------------------------------------
Vincoli sulle dipendenze
--------------------------------------

La figura che segue illustra come i Controllers e i Presenters comunicano con gli Uses Cases
del livello superiore.

.. image:: ./_static/img/Architectures/cleanArchControllerAdUseCases.png
   :align: center

Il flusso di controllo si origina dal Controller per passare poi allo UseCase e al Presenter.
Lo scopo del Presenter è di separare i casi d'uso dal formato dell'interfaccia utente.

Per evitare la dipendenza dello UseCase dal Presenter
(cioè per rispettare il vincolo che sono sempre gli anelli esterni  a dover dipendere da quelli interni e mai viceversa), 
si possono usare due tecniche principali:

- Ricorrendo al principio della `inversione delle dipendenze <https://en.wikipedia.org/wiki/Dependency_inversion_principle>`_
- Usando il pattern mediator.

++++++++++++++++++++++++++++++++++++
Inversione delle dipendenze
++++++++++++++++++++++++++++++++++++
Il principio della `inversione delle dipendenze <https://en.wikipedia.org/wiki/Dependency_inversion_principle>`_
stabilisce quanto segue:

- :remark:`I componenti di alto livello non devono dipendere da componenti di livello più basso.`
- :remark:`Le astrazioni non devono dipendere dai dettagli`.
  
  Sono i dettagli (ad esempio le implementazioni concrete) che devono dipendere dalle astrazioni.

 
+++++++++++++++++++++++++++++++++++++ 
Il pattern mediator
+++++++++++++++++++++++++++++++++++++
Nel `mediator pattern <https://en.wikipedia.org/wiki/Mediator_pattern>`_  due oggetti delegano la loro interazione a un terzo oggetto (il mediatore)
invece di interagire direttamente.

.. image:: ./_static/img/Architectures/meditorSequence.png
   :width: 50%
   :align: center

-------------------------------------- 
I principi SOLID
--------------------------------------

Questo tipo di architettura vuole anche promuovere i principi 
`SOLID <https://it.wikipedia.org/wiki/SOLID>`_ per la progettazione/costruzione pulita del software.

Si veda `Clean Architecture by Uncle Bob: Summary and review <https://clevercoder.net/2018/09/08/clean-architecture-summary-review>`_.  


  

